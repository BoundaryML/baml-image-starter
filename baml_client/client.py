###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
from typing import Dict, Generic, List, Optional, Tuple, TypeVar, Union
import pprint

import baml_py
from pydantic import BaseModel, ValidationError

from . import types

OutputType = TypeVar('OutputType')

class BamlOutputWrapper(BaseModel, Generic[OutputType]):
    wrapped: OutputType

class BamlOutput_ClassifyMessage:
    __runtime: baml_py.BamlRuntimeFfi

    def __init__(self, runtime: baml_py.BamlRuntimeFfi):
      self.__runtime = runtime

    async def __call__(
        self,
        input: str
    ) -> types.Category:
      raw = await self.__runtime.call_function(
        "ClassifyMessage",
        {
          "input": input,
        },
        ctx={}
      )
      parsed = raw.parsed()
      try:
        return BamlOutputWrapper[types.Category].model_validate(obj={'wrapped': parsed}).wrapped
      except ValidationError as e:
        raise TypeError(
          "Internal BAML error while mapping the FFI output type for ClassifyMessage:\n{}".format(
            pprint.pformat(parsed)
          )
        ) from e

    async def unstable(
        self,
        input: str
    ) -> baml_py.FunctionResult:
      return await self.__runtime.call_function(
        "ClassifyMessage",
        {
          "input": input,
        },
        ctx={}
      )

class BamlOutput_ClassifyMessage2:
    __runtime: baml_py.BamlRuntimeFfi

    def __init__(self, runtime: baml_py.BamlRuntimeFfi):
      self.__runtime = runtime

    async def __call__(
        self,
        input: str
    ) -> types.Category:
      raw = await self.__runtime.call_function(
        "ClassifyMessage2",
        {
          "input": input,
        },
        ctx={}
      )
      parsed = raw.parsed()
      try:
        return BamlOutputWrapper[types.Category].model_validate(obj={'wrapped': parsed}).wrapped
      except ValidationError as e:
        raise TypeError(
          "Internal BAML error while mapping the FFI output type for ClassifyMessage2:\n{}".format(
            pprint.pformat(parsed)
          )
        ) from e

    async def unstable(
        self,
        input: str
    ) -> baml_py.FunctionResult:
      return await self.__runtime.call_function(
        "ClassifyMessage2",
        {
          "input": input,
        },
        ctx={}
      )

class BamlOutput_ClassifyMessage3:
    __runtime: baml_py.BamlRuntimeFfi

    def __init__(self, runtime: baml_py.BamlRuntimeFfi):
      self.__runtime = runtime

    async def __call__(
        self,
        input: str
    ) -> types.Category:
      raw = await self.__runtime.call_function(
        "ClassifyMessage3",
        {
          "input": input,
        },
        ctx={}
      )
      parsed = raw.parsed()
      try:
        return BamlOutputWrapper[types.Category].model_validate(obj={'wrapped': parsed}).wrapped
      except ValidationError as e:
        raise TypeError(
          "Internal BAML error while mapping the FFI output type for ClassifyMessage3:\n{}".format(
            pprint.pformat(parsed)
          )
        ) from e

    async def unstable(
        self,
        input: str
    ) -> baml_py.FunctionResult:
      return await self.__runtime.call_function(
        "ClassifyMessage3",
        {
          "input": input,
        },
        ctx={}
      )

class BamlOutput_DescribeImage:
    __runtime: baml_py.BamlRuntimeFfi

    def __init__(self, runtime: baml_py.BamlRuntimeFfi):
      self.__runtime = runtime

    async def __call__(
        self,
        img: baml_py.Image
    ) -> str:
      raw = await self.__runtime.call_function(
        "DescribeImage",
        {
          "img": img,
        },
        ctx={}
      )
      parsed = raw.parsed()
      try:
        return BamlOutputWrapper[str].model_validate(obj={'wrapped': parsed}).wrapped
      except ValidationError as e:
        raise TypeError(
          "Internal BAML error while mapping the FFI output type for DescribeImage:\n{}".format(
            pprint.pformat(parsed)
          )
        ) from e

    async def unstable(
        self,
        img: baml_py.Image
    ) -> baml_py.FunctionResult:
      return await self.__runtime.call_function(
        "DescribeImage",
        {
          "img": img,
        },
        ctx={}
      )

class BamlOutput_DescribeImage2:
    __runtime: baml_py.BamlRuntimeFfi

    def __init__(self, runtime: baml_py.BamlRuntimeFfi):
      self.__runtime = runtime

    async def __call__(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image
    ) -> str:
      raw = await self.__runtime.call_function(
        "DescribeImage2",
        {
          "classWithImage": classWithImage,"img2": img2,
        },
        ctx={}
      )
      parsed = raw.parsed()
      try:
        return BamlOutputWrapper[str].model_validate(obj={'wrapped': parsed}).wrapped
      except ValidationError as e:
        raise TypeError(
          "Internal BAML error while mapping the FFI output type for DescribeImage2:\n{}".format(
            pprint.pformat(parsed)
          )
        ) from e

    async def unstable(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image
    ) -> baml_py.FunctionResult:
      return await self.__runtime.call_function(
        "DescribeImage2",
        {
          "classWithImage": classWithImage,"img2": img2,
        },
        ctx={}
      )

class BamlOutput_DescribeImage3:
    __runtime: baml_py.BamlRuntimeFfi

    def __init__(self, runtime: baml_py.BamlRuntimeFfi):
      self.__runtime = runtime

    async def __call__(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image
    ) -> str:
      raw = await self.__runtime.call_function(
        "DescribeImage3",
        {
          "classWithImage": classWithImage,"img2": img2,
        },
        ctx={}
      )
      parsed = raw.parsed()
      try:
        return BamlOutputWrapper[str].model_validate(obj={'wrapped': parsed}).wrapped
      except ValidationError as e:
        raise TypeError(
          "Internal BAML error while mapping the FFI output type for DescribeImage3:\n{}".format(
            pprint.pformat(parsed)
          )
        ) from e

    async def unstable(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image
    ) -> baml_py.FunctionResult:
      return await self.__runtime.call_function(
        "DescribeImage3",
        {
          "classWithImage": classWithImage,"img2": img2,
        },
        ctx={}
      )

class BamlOutput_DescribeImage4:
    __runtime: baml_py.BamlRuntimeFfi

    def __init__(self, runtime: baml_py.BamlRuntimeFfi):
      self.__runtime = runtime

    async def __call__(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image
    ) -> str:
      raw = await self.__runtime.call_function(
        "DescribeImage4",
        {
          "classWithImage": classWithImage,"img2": img2,
        },
        ctx={}
      )
      parsed = raw.parsed()
      try:
        return BamlOutputWrapper[str].model_validate(obj={'wrapped': parsed}).wrapped
      except ValidationError as e:
        raise TypeError(
          "Internal BAML error while mapping the FFI output type for DescribeImage4:\n{}".format(
            pprint.pformat(parsed)
          )
        ) from e

    async def unstable(
        self,
        classWithImage: types.ClassWithImage,img2: baml_py.Image
    ) -> baml_py.FunctionResult:
      return await self.__runtime.call_function(
        "DescribeImage4",
        {
          "classWithImage": classWithImage,"img2": img2,
        },
        ctx={}
      )

class BamlOutput_ExtractNames:
    __runtime: baml_py.BamlRuntimeFfi

    def __init__(self, runtime: baml_py.BamlRuntimeFfi):
      self.__runtime = runtime

    async def __call__(
        self,
        input: str
    ) -> List[str]:
      raw = await self.__runtime.call_function(
        "ExtractNames",
        {
          "input": input,
        },
        ctx={}
      )
      parsed = raw.parsed()
      try:
        return BamlOutputWrapper[List[str]].model_validate(obj={'wrapped': parsed}).wrapped
      except ValidationError as e:
        raise TypeError(
          "Internal BAML error while mapping the FFI output type for ExtractNames:\n{}".format(
            pprint.pformat(parsed)
          )
        ) from e

    async def unstable(
        self,
        input: str
    ) -> baml_py.FunctionResult:
      return await self.__runtime.call_function(
        "ExtractNames",
        {
          "input": input,
        },
        ctx={}
      )

class BamlOutput_GetOrderInfo:
    __runtime: baml_py.BamlRuntimeFfi

    def __init__(self, runtime: baml_py.BamlRuntimeFfi):
      self.__runtime = runtime

    async def __call__(
        self,
        email: types.Email
    ) -> types.OrderInfo:
      raw = await self.__runtime.call_function(
        "GetOrderInfo",
        {
          "email": email,
        },
        ctx={}
      )
      parsed = raw.parsed()
      try:
        return BamlOutputWrapper[types.OrderInfo].model_validate(obj={'wrapped': parsed}).wrapped
      except ValidationError as e:
        raise TypeError(
          "Internal BAML error while mapping the FFI output type for GetOrderInfo:\n{}".format(
            pprint.pformat(parsed)
          )
        ) from e

    async def unstable(
        self,
        email: types.Email
    ) -> baml_py.FunctionResult:
      return await self.__runtime.call_function(
        "GetOrderInfo",
        {
          "email": email,
        },
        ctx={}
      )



class BamlClient:
    __runtime: baml_py.BamlRuntimeFfi
    ClassifyMessage: BamlOutput_ClassifyMessage
    ClassifyMessage2: BamlOutput_ClassifyMessage2
    ClassifyMessage3: BamlOutput_ClassifyMessage3
    DescribeImage: BamlOutput_DescribeImage
    DescribeImage2: BamlOutput_DescribeImage2
    DescribeImage3: BamlOutput_DescribeImage3
    DescribeImage4: BamlOutput_DescribeImage4
    ExtractNames: BamlOutput_ExtractNames
    GetOrderInfo: BamlOutput_GetOrderInfo

    @staticmethod
    def from_encoded(encoded: str) -> "BamlClient":
      return BamlClient(runtime=baml_py.BamlRuntimeFfi.from_encoded(encoded))

    @staticmethod
    def from_directory(path: str) -> "BamlClient":
      return BamlClient(runtime=baml_py.BamlRuntimeFfi.from_directory(path))

    def __init__(self, runtime: baml_py.BamlRuntimeFfi):
      self.__runtime = runtime
      self.ClassifyMessage = BamlOutput_ClassifyMessage(self.__runtime)
      self.ClassifyMessage2 = BamlOutput_ClassifyMessage2(self.__runtime)
      self.ClassifyMessage3 = BamlOutput_ClassifyMessage3(self.__runtime)
      self.DescribeImage = BamlOutput_DescribeImage(self.__runtime)
      self.DescribeImage2 = BamlOutput_DescribeImage2(self.__runtime)
      self.DescribeImage3 = BamlOutput_DescribeImage3(self.__runtime)
      self.DescribeImage4 = BamlOutput_DescribeImage4(self.__runtime)
      self.ExtractNames = BamlOutput_ExtractNames(self.__runtime)
      self.GetOrderInfo = BamlOutput_GetOrderInfo(self.__runtime)